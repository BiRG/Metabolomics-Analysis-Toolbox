function candidates = reconstruct_bin_boundaries_file( original_collection_filename, binned_collection_filename, reconstructed_bin_boundaries_filename )
% Reads an original collection and its binned version generated by DAB and reconstructs the bin boundaries that were used to generated the binned copy
%
% Usage: reconstruct_bin_boundaries_file( original_collection_filename, binned_collection_filename, reconstructed_bin_boundaries_filename )
% -------------------------------------------------------------------------
% Input arguments
% -------------------------------------------------------------------------
%
% original_collection_filename - 
%     the name of the text file from which to read the original collection.
%     Must be suitable for loading with load_collection. The x values must
%     be monotonic increasing or decreasing.
%
% binned_collection_filename -
%     the name of the text file from which to read the binned collection.
%     Must be suitable for loading with load_collection. Must have been
%     generated by DAB (that is, the bin x values must be the bin centers).
%
% reconstructed_bin_boundaries_filename -
%     the file that will hold the reconstructed bin boundaries. Will be
%     overwritten. Will be suitable for loading with the "Load bins" button
%     in the dynamic adaptive binning application "Results" tab.
%
% -------------------------------------------------------------------------
% Output parameters
% -------------------------------------------------------------------------
% 
% none
%
% -------------------------------------------------------------------------
% Examples
% -------------------------------------------------------------------------
%
% >> reconstruct_bin_boundaries_file( 'foo', 'foo.binned', 'foo.bounds' )
% Reads a collection from foo and one from foo.binned, reconstructs the
% boundaries that generated foo.binned from foo and writes them to
% 'foo.bounds'
% 
% -------------------------------------------------------------------------
% Authors
% -------------------------------------------------------------------------
%
% Paul Anderson ????
% Eric Moyer 2012 (eric_moyer@yahoo.com)

orig_col = load_collection(original_collection_filename,'');
if ~isstruct(orig_col)
    error('bin_reconstruct_bin_boundaries:no_load',...
        'Could not load collection from %s', original_collection_filename);
end
binned_col = load_collection(binned_collection_filename,'');
if ~isstruct(binned_col)
    error('bin_reconstruct_bin_boundaries:no_load',...
        'Could not load collection from %s', binned_collection_filename);
end


wait_h = waitbar(0,'Generating bin centers for all pairs of bins ');
orig_x = orig_col.x;
binned_x = binned_col.x;

if ~(issorted(orig_x) || issorted(fliplr(orig_x)))
    error('bin_reconstruct_bin_boundaries:not_sorted',...
        'The x values in %s are not sorted.', original_collection_filename);
end

num_pairs = length(orig_x)*(length(orig_x)-1)/2;
candidates = cell(size(binned_x));
rounding_factor = 10000; % Use a fixed point integer representation with 4 
                         % decimal places for "rounded" values.
                         % This rounding takes care of the loss of
                         % precision that occurs when reading/writing
                         % floating point values from/to a text file.
rounded_binned_x = round(binned_x * rounding_factor); 
for idx1=1:length(orig_x)
    num_pairs_remaining = (length(orig_x)-idx1+1)*(length(orig_x)-idx1)/2;
    frac_done = 1 - num_pairs_remaining/num_pairs;
    waitbar(frac_done, wait_h);
    
    coord_1 = orig_x(idx1);
    idx2 = idx1:length(orig_x);
    centers = (coord_1 + orig_x(idx2)) / 2;
    rounded_centers = round(centers * rounding_factor);
    potential_bin_indices = find(rounded_binned_x <= max(rounded_centers) & rounded_binned_x >= min(rounded_centers));
    for i = 1:length(potential_bin_indices)
        bin_idx = potential_bin_indices(i);
        matches = rounded_binned_x(bin_idx) == rounded_centers;
        if any(matches)
            candidates{bin_idx} = [candidates{bin_idx}, centers(matches)];
        end
    end
end

% Get rid of the waitbar
close(wait_h);

end

