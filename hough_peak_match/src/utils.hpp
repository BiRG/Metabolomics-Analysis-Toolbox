///\file
///\brief Global utility classes used throughout peak matching
#ifndef HOUGH_PEAK_MATCH_UTILS_HPP
#define HOUGH_PEAK_MATCH_UTILS_HPP

#include <string>
#include <vector>
#include <limits>
#include <iostream>

namespace HoughPeakMatch{

///\brief Split a string on white-space into a vector of strings
///
///Ignoring starting and ending white-space, extracts all contiguous
///white-space separated substrings in order and puts them in a
///vector.
///
///\code
///split("  The rain  in spain\nFalls mainly on the plain      ");
///\endcode
///
///returns a vector containing the c++ strings, 
///("The", "rain", "in", "spain", "Falls", "mainly", "on", "the", "plain")
///
///\param s The string that will be split
///\returns an array of strings generated by splitting the input string
std::vector<std::string> split(const std::string& s);

///\brief Return true if \a d is NAN, false otherwise
///
///\param d the value being tested for NAN'ness
///
///\return true if \a d is NAN, false otherwise
inline bool is_nan(double d){ return d != d; }

///\brief Return true if \a d is NAN, infinity or -infinity false otherwise
///
///\param d the value being tested for specialness
///
///\return true if \a d is NAN, infinity or -infinity false otherwise
bool is_special_double(double d);

///\brief Return true if \a s contains white-space
///
///\param s the string to be searched for white-space
///
///\return true if \a s contains white-space
bool contains_white_space(const std::string s);

///\brief Writes a space-separated version of \a v to \a out,
///\brief returning \a out
///
///The list {1,2,3} will be space separated into "1 2 3" -
///spaces only between entries.  ostream_iterator would insert
///spaces after entries.  T is expected to have an ostream
///insertion operator.
///
///The code is not the prettiest, but it works and avoids
///writing everything to an intermediate string.
///
///Example:
///\code
///out << "This is my vector: "; space_separate(out,my_vector) << endl;
///\endcode
///
///\param out The ostream to which the items are written
///
///\param v the vector of items to write
///
///\return the stream after writing to it (so << sequence can be continued)
///
///\tparam T the class contained in the vector
template<class T>
std::ostream& space_separate(std::ostream &out, const std::vector<T>& v){
  typename std::vector<T>::const_iterator it = v.begin();
  if(it != v.end()){
    out << *it;
    ++it;
  }
  while(it != v.end()){
    out << " " << *it;
    ++it;
  }
  return out;
}

}

#endif
