///\file
///\brief Global utility classes used throughout peak matching
#ifndef HOUGH_PEAK_MATCH_UTILS_HPP
#define HOUGH_PEAK_MATCH_UTILS_HPP

#include <string>
#include <vector>
#include <limits>
#include <iostream>
#include <memory>
#include <stdexcept>

namespace HoughPeakMatch{

///\brief Split a string on white-space into a vector of strings
///
///Ignoring starting and ending white-space, extracts all contiguous
///white-space separated substrings in order and puts them in a
///vector.
///
///\code
///split("  The rain  in spain\nFalls mainly on the plain      ");
///\endcode
///
///returns a vector containing the c++ strings, 
///("The", "rain", "in", "spain", "Falls", "mainly", "on", "the", "plain")
///
///\param s The string that will be split
///\returns an array of strings generated by splitting the input string
std::vector<std::string> split(const std::string& s);

///\brief Return true if \a d is NAN, false otherwise
///
///\param d the value being tested for NAN'ness
///
///\return true if \a d is NAN, false otherwise
inline bool is_nan(double d){ return d != d; }

///\brief Return true if \a d is NAN, infinity or -infinity false otherwise
///
///\param d the value being tested for specialness
///
///\return true if \a d is NAN, infinity or -infinity false otherwise
bool is_special_double(double d);

///\brief Return true if \a s contains white-space
///
///\param s the string to be searched for white-space
///
///\return true if \a s contains white-space
bool contains_white_space(const std::string s);

///\brief Writes a space-separated version of \a v to \a out,
///returning \a out
///
///The list {1,2,3} will be space separated into "1 2 3" -
///spaces only between entries.  ostream_iterator would insert
///spaces after entries.  T is expected to have an ostream
///insertion operator.
///
///The code is not the prettiest, but it works and avoids
///writing everything to an intermediate string.
///
///Example:
///\code
///out << "This is my vector: "; space_separate(out,my_vector) << endl;
///\endcode
///
///\param out The ostream to which the items are written
///
///\param v the vector of items to write
///
///\return the stream after writing to it (so << sequence can be continued)
///
///\tparam T the class contained in the vector
///
///\todo (low priority) Write tests specifically for this.  Not really
///necessary as it gets exercised by other functions
template<class T>
std::ostream& space_separate(std::ostream &out, const std::vector<T>& v){
  typename std::vector<T>::const_iterator it = v.begin();
  if(it != v.end()){
    out << *it;
    ++it;
  }
  while(it != v.end()){
    out << " " << *it;
    ++it;
  }
  return out;
}

///\brief dot product of two vectors
///
///\a a and \a b must be the same length
///
///\param a The first vector, same length as \a b
///
///\param b the second vector, same length as \a a
///
///\return the dot product of \a a and \a b
///
///\throw std::invalid_argument if the vectors are different lengths
inline double dot(const std::vector<double>& a, const std::vector<double>& b){
  if(a.size() != b.size()){
    throw std::invalid_argument
      ("Different sized arguments to HoughPeakMatch::dot");
  }
  double sum = 0;
  std::vector<double>::const_iterator ita, itb;
  for(ita = a.begin(), itb = b.begin(); ita != a.end(); ++ita){
    sum += (*ita) * (*itb);
  }
  return sum;
}

///\brief dynamic cast that works for autoptrs
///
///Use:
///\code
///auto_ptr<Foo> f = foo_returning_method;
///auto_ptr<Bar> b = auto_ptr_dynamic_cast<Bar>(f);
///\endcode
///On a successful cast, b owns the object and f has released it.
///On failure, b is null and f still owns the object.
///
///Code from: http://stackoverflow.com/questions/518959/why-does-this-dynamic-cast-of-auto-ptr-fail
///
///\param in The auto_ptr that will be dynamic cast to type \a R
///
///\return On success returns an auto_ptr<R> that owns the object
///pointed to by \a in.  On failure, in is unchanged and returns NULL.
///
///\tparam T the type of the original auto_ptr
///
///\tparam R the type of the returned auto_ptr
template<typename R, typename T>
std::auto_ptr<R> auto_ptr_dynamic_cast(std::auto_ptr<T>& in) {
  std::auto_ptr<R> rv;
  R* p;
  if( (p = dynamic_cast<R*>( in.get() )) ) {
      in.release();
      rv.reset(p);
  }
  return rv;
}

}

#endif
