#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Pathological cases for MIC
\end_layout

\begin_layout Standard
My basic idea is to use low-discrepancy sequences to fool MIC into thinking
 that the sequence is random.
\end_layout

\begin_layout Standard
Though the authors' proofs are valid, they depend for their generality on
 the impossibility of choosing uniformly over a countably infinite set (for
 example, the rationals or the naturals).
\end_layout

\begin_layout Standard
With finite word-size, I can restore that uniformity because the reduction
 to a finite word-size constitutes a pre-binning of the data over a pre-specifie
d non-adaptive grid.
\end_layout

\begin_layout Standard
If I am given both the word-size and the number of samples in advance, I
 can create a distribution that will always fool the MIC into thinking it
 is random (when it is in reality a function.).
\end_layout

\begin_layout Standard
The basic idea is as follows: flip a very biased coin as to whether the
 number is chosen from the integers in the word size or from the rest of
 the natural numbers.
 Let almost all of the mass except for a negligible amount be concentrated
 on choosing from the word-size.
 On the off-chance that you chose the rest of the natural numbers, choose
 i geometrically with a mean of twice the maximum integer and add the maximum
 integer.
 Normally, choose i uniformly on the natural numbers in the given word-size.
 Then output the i
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

base 2 van der Corput number and the i
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

base 3 number.
 (This is the i
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

entry in the 2,3 Halton sequence.) You can choose to have so much probability
 mass on 1 that the liklihood of choosing one of the other word-size multiples
 in your sample size is effectively 0.
\end_layout

\begin_layout Standard
You can also skip the whole complicated choosing procedure and just choose
 randomly in the word size.
 That will be covered approximately uniformly and the repetitions of individual
 entries (which on infinite resolution would give away the non-randomness)
 will be covered by the finite resolution.
\end_layout

\begin_layout Standard
Something similar can be done by making a very high frequency sine wave.
 It is effectively a bar above a certain resolution.
 The algorithm will interpret this as a uniform distribution over the interval.
\end_layout

\begin_layout Standard
Note, I tried it and the sine function is less dense in the middle and more
 dense on the edges (due to the differing slopes).
\end_layout

\end_body
\end_document
