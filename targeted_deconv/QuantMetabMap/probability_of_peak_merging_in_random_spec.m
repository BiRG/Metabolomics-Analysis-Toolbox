function results = probability_of_peak_merging_in_random_spec( numbers_of_peaks, numbers_of_peak_widths, num_reps, num_intensities, use_waitbar )
% Return a monte-carolo estimate the joint probability distribution of certain numbers of local maxima being generated in a random spectrum when 
%
% Usage: results = probability_of_peak_merging_in_random_spec( numbers_of_peaks, numbers_of_peak_widths, num_reps )
%
% Takes the cartesian product of the two input vectors numbers_of_peaks,
% and numbers_of_peak widths (that is, all combinations of the entries of
% those two vectors) and generates num_reps noiseless spectra for each 
% entry in the cartesian product. These spectra are sampled at 
% num_intensities points and then the local maxima are found. A flat area
% is not counted as a local maximum, but an end-point whose adjacent point
% is less is counted as a local maximum. In general a local maximum has an
% intensity strictly greater than its neighbors. Since the spectrum is
% noiseless there cannot be more maxima than peaks. The number of times
% each number of local maxima was found is recorded for each cartesian
% product entry. Then the next entry is simulated.
%
% Input params:
%
% numbers_of_peaks - (vector) each entry in this vector is a number of
%            peaks to use in a trial.
%
% numbers_of_peak_widths - (vector) each entry in this vector represents a
%            generation interval to use in a trial measured in terms of the
%            mean peak half width at half height used the generating 
%            distribution in random_spec_from_nssd_data. So a 1 would
%            indicate an interval 0.00453630122481774988 ppm wide.
%
% num_reps - (scalar) the number of noiseless random spectra to generate 
%            for each member of the cartesian product of numbers_of_peaks 
%            and numbers_of_peak_widths
%
% num_intensities - (scalar) the number of intensities to use for each
%            generated spectrum
%
% use_waitbar - (logical, optional) if true, then a waitbar is used
%            otherwise no waitbar is used. If omitted, then treated as
%            true.
%
% Output params:
%
% results - (vector of struct) Each entry in this vector has 4 fields and
%           represents the result of the num_reps trials for one member of
%           the cartesian product of numbers_of_peaks and
%           numbers_of_peak_widths. The fields are as follows:
%
%           num_peaks - (scalar) the number of peaks used in the trial
%
%           num_widths - (scalar) the number of mean peak widths wide the
%                   is the interval in which the spectrum was generated.
%
%           width - (scalar) width (in ppm) of the interval used in the
%                   trial
%
%           mean_width - (scalar) the mean half width at half height
%                   generated by random_spec_from_nssd_data
%
%           num_reps - (scalar) the number of repetitions used in the trial
%
%           counts - (vector) has length num_peaks. counts(i) is the number
%                   of times there were i local maxima detected. subtract
%                   the sum from num_reps to determine the number of times
%                   0 local maxima were detected.
%
% Example:
%
% c = probability_of_peak_merging_in_random_spec( [1:3], [1,5:5:15], 100 )
%
% Generates 100 spectra for each combination in the cartesian product of
% the arrays [1,2,3] and [1,5,10,15], that is for all pairs (1,1), (1,5),
% (1,10), (1,15), (2,1), (2,5), (2,10), (2,15), (3,1), (3,5), (3,10), and
% (3,15). For each of these pairs (a,b), c will contain a struct with
% fields num_peaks, width, num_reps, and counts. Counts will be a row
% vector whose i'th entry will be the number of times in the 100 that 
% i local maxima were detected in the interval. c.num_reps will be
% 100 but is saved so that it is easy to count the number of times 0 local
% maxima were detected
%

if ~exist('use_waitbar','var')
    use_waitbar = true;
end

% Mean peak half width at half height from random_spec_from_nssd_data
mean_width = 0.00453630122481774988;

% Generate the cartesian product of the two parameters
[A,B] = meshgrid(numbers_of_peaks, numbers_of_peak_widths);
pairs = [A(:),B(:)];

% Generate the results
num_pairs = size(pairs,1);
results(num_pairs).num_peaks = 0; % Preallocate results as a struct array
if use_waitbar
    wait_h = waitbar(0,'Running monte-carlo simulation');
end
for i = 1:num_pairs
    if use_waitbar
        waitbar((i-1)/num_pairs, wait_h);
    end
    num_peaks = pairs(i,1);
    width = pairs(i,2)*mean_width;
    
    % Fill simple results fields
    results(i).num_peaks = num_peaks;
    results(i).num_widths = pairs(i,2);
    results(i).width = width;
    results(i).mean_width = mean_width;
    results(i).num_reps = num_reps;
    
    % Fill counts field in results 
    results(i).counts = zeros(1,num_peaks);
    for rep = 1:num_reps
        if use_waitbar && mod(rep,16) == 0
            waitbar((i-1)/num_pairs+rep/(num_pairs*num_reps), wait_h);
        end
        sp = random_spec_from_nssd_data(num_peaks, 0, width, ...
            num_intensities, 0);
        assert(issorted(sp.x) || issorted(fliplr(sp.x)));
        y = sp.Y;
        % Count the number of local maxima - those points with no better
        % right or left neighbors
        points_with_right_neighbor = y(1:end-1); % all except right end
        right_neighbors = y(2:end);
        points_with_left_neighbor = right_neighbors; %all except for left end
        left_neighbors = points_with_right_neighbor;
        has_better_right_neighbor = [points_with_right_neighbor <= right_neighbors;false];
        has_better_left_neighbor =[false; points_with_left_neighbor <= left_neighbors];
        is_local_max = ~(has_better_right_neighbor | has_better_left_neighbor);
        num_local_max = sum(is_local_max,1);
        if num_local_max > 0
            results(i).counts(num_local_max) = 1 + results(i).counts(num_local_max); 
        end
    end
end

% Close the waitbar now that we're done
if use_waitbar
    close(wait_h);
end

end

