function show_bin(region_inx)
collections = getappdata(gcf,'collections');
if exist('region_inx')
    [region_inx,left,right,left_handle] = get_region(region_inx);
else
    [region_inx,left,right,left_handle] = get_region;
end
info = getappdata(left_handle,'info');
if isempty(info)
    info = {};
    info.binning_method = 'sum';
end

regions = get_regions;
padding = 0.05; % Padding on each side of the function
new_bin_left = left;
if region_inx > 1
    new_bin_left = regions(region_inx-1,1);
end
far_left = max([new_bin_left,left+padding]);
new_bin_right = right;
nm = size(regions);
if region_inx < nm(1)
    new_bin_right = regions(region_inx+1,2);
end
far_right = min([new_bin_right,right-padding]);

calling_gcf = gcf;
ax = get(calling_gcf,'CurrentAxes');
xl = get(ax,'xlim');
yl = get(ax,'ylim');
fhs = getappdata(calling_gcf,'fhs');
fh = figure;
%% Regular binning
subplot(1,2,1);
fhs(end+1) = fh;
setappdata(calling_gcf,'fhs',fhs);

yhs = [];
% Make sure black
colors = get(gca,'colororder');
nm = size(colors);
offset = -1;
for i = 1:nm(1)
    s = sum(colors(i,:));
    if s == 0
        offset = i;
    end
end
if offset == -1
    colors(end+1,:) = [0,0,0];
    nm = size(colors);
    offset = nm(1);
end
legend_cell = {};
for i = 1:length(collections)
    inxs = find(far_left >= collections{i}.x & collections{i}.x >= far_right);
    hl = line(collections{i}.x(inxs),collections{i}.Y(inxs,1),'Color',colors(mod(i+offset-2,length(colors))+1,:));
    myfunc = @(hObject, eventdata, handles) (line_click_info(collections{i},1));
    set(hl,'ButtonDownFcn',myfunc);
    yhs(end+1) = hl;
    % Change the following line if you want to change the legend for
    % each collection
    legend_cell{end+1} = num2str(collections{i}.description);
end
line([left,left],yl,'Color','r');
line([right,right],yl,'Color','r');
lh = legend(legend_cell);
for i = 1:length(collections)
    for j = 2:collections{i}.num_samples
        inxs = find(far_left >= collections{i}.x & collections{i}.x >= far_right);
        hl = line(collections{i}.x(inxs),collections{i}.Y(inxs,j),'Color',colors(mod(i+offset-2,length(colors))+1,:));
        myfunc = @(hObject, eventdata, handles) (line_click_info(collections{i},j));
        set(hl,'ButtonDownFcn',myfunc);
        yhs(end+1) = hl;
    end
end
setappdata(gcf,'yhs',yhs);
setappdata(gcf,'lh',lh);

set(gcf,'CloseRequestFcn',@closing_child_window);
setappdata(gcf,'yhs',yhs);
setappdata(gcf,'main_h',calling_gcf);
set(gca,'xdir','reverse')
set(gca,'xlim',[right,left]);
set(gca,'ylim',yl);
xlabel('Chemical shift, ppm')
ylabel('Intensity')
ax1 = gca;

%% Adjacent deconvolution
subplot(1,2,2);

yhs = [];
legend_cell = {};
for i = 1:length(collections)
    xmaxs = collections{i}.spectra{1}.xmaxs;
    max_inxs = find(left >= xmaxs & xmaxs >= right);
    xmins = collections{i}.spectra{1}.xmins(max_inxs,:);
    if isempty(xmins)
        left_min = left;
        right_min = right;
    else
        left_min = max(xmins(:,1));
        right_min = min(xmins(:,2));
    end
    inxs = find(left_min >= collections{i}.x & collections{i}.x >= right_min);
    
    y_fit = collections{i}.Y([inxs(1),inxs(end)],1);

%     % Small adjustments to boundaries
%     xmins = [collections{i}.spectra{1}.xmins(:,1);collections{i}.spectra{1}.xmins(:,2)];
%     diffs = xmins - far_left;
%     tinxs = find(diffs >= 0);
%     diffs = diffs(tinxs);
%     if ~isempty(diffs)
%         [vs,ixs] = sort(diffs,'ascend');
%         far_left_min = xmins(tinxs(ixs(1)));
%     else
%         far_left_min = far_left;
%     end
%     diffs = far_right - xmins;
%     tinxs = find(diffs >= 0);
%     diffs = diffs(tinxs);
%     if ~isempty(diffs)
%         [vs,ixs] = sort(diffs,'ascend');
%         far_right_min = xmins(tinxs(ixs(1)));
%     else
%         far_right_min = far_right;
%     end
%     
%     inxs = find(far_left_min >= collections{i}.x & collections{i}.x >= far_right_min);
%     [y_fit,fit_inxs,MGPX,baseline_BETA,x_baseline_BETA,xmaxs] = curve_fit_helper(collections,i,1,left,right,far_left_min,far_right_min);
%     X = MGPX(4:4:end);
%     xinxs = [find(X >= left),find(X <= right)];
%     MGPX_o = [];
%     for k = 1:length(xinxs)
%         MGPX_o = [MGPX_o,MGPX(4*(xinxs(k)-1)+(1:4))];
%     end
%     model = @(PARAMS,x_) (global_model(PARAMS,x_,length(xinxs),x_baseline_BETA));
%     y_fit = model([MGPX_o,baseline_BETA],collections{i}.x');
    y_bin = collections{i}.Y(:,1) - y_fit;

    hl = line(collections{i}.x(inxs),y_bin(inxs),'Color',colors(mod(i+offset-2,length(colors))+1,:));
    myfunc = @(hObject, eventdata, handles) (plot_line(collections{i},1,inxs,y_fit,collections{i}.spectra{1}.y_smoothed,new_bin_left,new_bin_right,xmaxs));
    set(hl,'ButtonDownFcn',myfunc);
    yhs(end+1) = hl;
    % Change the following line if you want to change the legend for
    % each collection
    legend_cell{end+1} = num2str(collections{i}.description);
end
lh = legend(legend_cell);
line([new_bin_left,new_bin_left],yl,'Color','r');
line([new_bin_right,new_bin_right],yl,'Color','r');
for i = 1:length(collections)
    for j = 2:collections{i}.num_samples
        % Small adjustments to boundaries
        xmins = [collections{i}.spectra{j}.xmins(:,1);collections{i}.spectra{j}.xmins(:,2)];
        diffs = xmins - far_left;
        tinxs = find(diffs >= 0);
        diffs = diffs(tinxs);
        if ~isempty(diffs)
            [vs,ixs] = sort(diffs,'ascend');
            far_left_min = xmins(tinxs(ixs(1)));
        else
            far_left_min = far_left;
        end
        diffs = far_right - xmins;
        tinxs = find(diffs >= 0);
        diffs = diffs(tinxs);
        if ~isempty(diffs)
            [vs,ixs] = sort(diffs,'ascend');
            far_right_min = xmins(tinxs(ixs(1)));
        else
            far_right_min = far_right;
        end
        
        inxs = find(far_left_min >= collections{i}.x & collections{i}.x >= far_right_min);
        [y_fit,fit_inxs,MGPX,baseline_BETA,x_baseline_BETA,xmaxs] = curve_fit_helper(collections,i,j,left,right,far_left_min,far_right_min);
        X = MGPX(4:4:end);
        xinxs = [find(X >= left),find(X <= right)];
        MGPX_o = [];
        for k = 1:length(xinxs)
            MGPX_o = [MGPX_o,MGPX(4*(xinxs(k)-1)+(1:4))];
        end
        model = @(PARAMS,x_) (global_model(PARAMS,x_,length(xinxs),x_baseline_BETA));
        y_fit = model([MGPX_o,baseline_BETA],collections{i}.x');
        y_bin = collections{i}.Y(:,j) - y_fit;

        hl = line(collections{i}.x(inxs),y_bin(inxs),'Color',colors(mod(i+offset-2,length(colors))+1,:));
        myfunc = @(hObject, eventdata, handles) (plot_line(collections{i},j,inxs,y_fit,collections{i}.spectra{j}.y_smoothed,new_bin_left,new_bin_right,xmaxs));
        set(hl,'ButtonDownFcn',myfunc);
        yhs(end+1) = hl;
    end
end
setappdata(gcf,'yhs',yhs);
setappdata(gcf,'lh',lh);

set(gcf,'CloseRequestFcn',@closing_child_window);
setappdata(gcf,'yhs',yhs);
setappdata(gcf,'main_h',calling_gcf);
set(gca,'xdir','reverse')
set(gca,'xlim',[far_right,far_left]);
set(gca,'ylim',yl);
xlabel('Chemical shift, ppm')
ylabel('Intensity')
myfunc = @(hObject, eventdata, handles) (select_binning_method_adj(subplot(1,2,1),subplot(1,2,2),left_handle));
set(gca,'ButtonDownFcn',myfunc)
myfunc = @(hObject, eventdata, handles) (select_binning_method_sum(subplot(1,2,2),subplot(1,2,1),left_handle));
set(ax1,'ButtonDownFcn',myfunc)
if strcmp(info.binning_method,'sum')
    select_binning_method_sum(subplot(1,2,2),subplot(1,2,1),left_handle);
elseif strcmp(info.binning_method,'adj')
    select_binning_method_adj(subplot(1,2,1),subplot(1,2,2),left_handle);
end

setappdata(left_handle,'info',info);